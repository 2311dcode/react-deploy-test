<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=%REACT_APP_KAKAO_API%"></script>
  <title>React App</title>
</head>

<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
</body>

</html>

<!-- 
Generator : 해당 함수 안쪽의 자식 자식 함수으 ㅣ리턴값을 반복가능한 객체 형태로 묶어서 반환(Iterable Object)

Iterable Object : next라는 메서드를 호출해서 Generator 안쪽에 있는 함수들을 원하는 시점에 동기적을 ㅗ호출 가능 

promise(then, catch, async await)와 더불어서 ES7이후에 나온 동기화 처리 함수 

promise대비 Generator 장점 
- promise와는 달리 특정 코드를 동기화시킬때 호출시점을 지정가능 
- 하나의 함수안에서 리턴값을 여러개 반환 가능 

redux-saga에서 genarator를 쓰는 이유 
-기존의 redux 서버데이터요청, 응답성공, 응답실페에 대한 모든 과정을 개발자가 관리해서 값을 리듀서에 넘겨주는 구조
-- saga는 자체적으로 redux시스템에서 위의 모든 과정을 스스로 관리하기 때문에 동기적으로 실행해야 되는 함수들으 많이 있음 
-saga에서는 모든 함수를 generator로 구성 해서 saga가 적절한 시점에 내부 함수를 동기적으로 호출가능 

function test1(){
  console.log("test1"); 
  return 'test1'; 
}
function test2(){
  console.log("test2"); 
  return 'test2'; 
}
function test3(){
  console.log("test3"); 
  return 'test3'; 
}

//복잡한 비동기를 동기화 시키려고 함 
//함수호출하는 순간 객체형태로 묶어서 원하는 시점에 호출 
function* generator(){
  yield test1(); 
  yield test2(); 
  yield test3(); 
}

const result = generator(); 
const r1 = result.next(); 
console.log(r1); //{value:'test1', done:false} //false는 아직 반복가능 뜻 

console.log('중간작업'); 
const r2 = result.next();  //test2 
console.log(r2); // { value:'test2',  done:false}

console.log('last'); 
const last = result.next();  //test3 
console.log(last); // { value:undefined,  done:true} //더 작업할게 없다 

//백엔드에서 데이터 불러올때  값 찾아서 목록에 래핑되어있는 자료 다시 찾아야 하기 때문에 콜백헬이 됨 
이 엡스를 피하기 위해서 genarator를 썼음  
// 받는 여러 가지 함수중에 원하는 시점에 .next()로  동기적으로 호출 가능한 장점 


 -->